---
title: "Volatilidade e VaR"
author: "Viviane Sanchez"
Institution: "Insper - Programa Avançado em Data Science"
date: "10/31/2020"
runtime: shiny
output: html_document
---

# Introdução

"A apresentação deve ser sucinta, contendo principalmente as conclusões de cada passo. O script deverá ser entregue junto com a apresentação e deve ser de fácil leitura. A avaliação deve levar em conta principalmente a lógica e clareza da argumentação do modelo escolhido e os cálculos realizados."

## Pacotes

```{r setup, include=FALSE}

#knitr::opts_chunk$set(message = FALSE, warning = FALSE, 
#                      fig.retina = 2 ,fig.height=5, fig.width=10)


library(tidyverse)
library(tidyquant)
library(tidymodels)
library(tidytext)
library(readxl)
library(skimr)

library(sweep)
library(timetk)


library(RcppRoll)
library(bizdays)
library(derivmkts)

library(rugarch)
library(forecast)
library(tseries)
library(fDMA)

library(ggrepel)
library(highcharter)
library(shiny)
library(knitr)


today <- Sys.Date()

bizdays.options$set(default.calendar='Brazil/ANBIMA')

theme_set(theme_minimal())
theme_update(text = element_text(family = "Open Sans", size = 12),
             plot.title = element_text(face = "bold", size = 23,
                                       color = "#1d3752"),
             legend.position = "bottom")

hc_cols <- c("#7cb5ec", "#434348", "#90ed7d", "#f7a35c", 
             "#8085e9", "#f15c80", "#e4d354", "#2b908f", 
             "#f45b5b", "#91e8e1")



#print(getwd())

```

## Objetivo

escolher duas ações do índice IBOVESPA ou SP500

# Dados

Para consulta das ações listadas no IBOV, foi extraída a [lista de ações] do site B3 do dia 30/10/20.

## Pré-processamento

```{r echo=TRUE}

ibov_raw <- list.files(path = 'data', 
                      pattern = "Ibovespa.xlsx",
                      full.names = TRUE) %>% 
    map_df(~read_excel(.), guess_max = 2000)


ibov <- ibov_raw %>% 
  janitor::clean_names() %>% 
  filter(str_detect(codigo, "\\d"))

ticker_max <- ibov %>% 
  filter(part_percent == max(part_percent)) %>% 
  pull(codigo)

ticker_min <- ibov %>% 
  filter(part_percent == min(part_percent)) %>% 
  pull(codigo)

ibov_list <- ibov %>% 
  select(codigo) %>% 
  mutate(ticker = paste(codigo,'.SA', sep = '')) %>% 
  pull(ticker)

```

O relatório será escrito baseando-se nas ações `r ticker_max` e `r ticker_min`, que são as duas ações com maior e menor participação no índice, respectivamente. No entanto, este relatório permite a simulação da análise com qualquer ação.

Para consulta das séries de preços, será utilizado o pacote `tidyquant` e os dados disponíveis através do [Yahoo! Finance](http://finance.yahoo.com). Para coleta e limpeza dos dados será utilizada a função a seguir:

```{r echo=TRUE}
get_price <- function(ticker,i_date){
    
b3_ts <- tq_get(ticker, get = "stock.prices", from = i_date) %>% 
         na.omit()

return(b3_ts)

}

```

# Análise gráfica

A seguir são feitas as análises gráficas dos preçoes e retornos. Os testes estatísticos necessários para verificar a presença de raiz unitária, normalidade, autocorrelação e efeitos ARCH serão no item seguinte.

## Preços

```{r include=FALSE}

 tickers <- c(paste(ticker_max,'.SA', sep = ''), paste(ticker_min,'.SA', sep = ''))
 
 prices <- get_price(tickers, "2018-01-01") %>% 
                   select(-close) %>% 
                   rename(close = adjusted) %>% 
            group_by(symbol) %>% 
                   tq_mutate(select = close,
                            mutate_fun = periodReturn,
                            period = "daily",
                            method = "log",
                            col_rename = "daily_return") %>% 
            mutate(return_acc = exp(cumsum(daily_return))-1,
                    sq_return = daily_return^2) %>% 
            ungroup()
 
 highchart(type = "stock") %>%
  hc_add_series(prices %>% select(-daily_return, -return_acc) %>% 
                     filter(str_detect(symbol, ticker_max)), 
                     type = "ohlc", hcaes(x = date),
                     name = ticker_max, color = hex_to_rgba("#7cb5ec", 1)) %>% 
   hc_add_series(prices %>% select(-daily_return, -return_acc) %>%
                   filter(str_detect(symbol, ticker_min)), type = "ohlc", 
                   hcaes(x = date), name = ticker_min, color = "#434348") %>% 
   hc_tooltip(valueDecimals = 2)
 
```

```{r echo=FALSE}

selectInput("ticker_id", label = "Ação", choices = ibov_list,
            multiple = T,
            selected = c("VALE3.SA","ECOR3.SA")) #"^BVSP"

dateRangeInput("date_id", label = "Selecione o período", 
               start = "2018-01-18")

actionButton("update_button", "Atualizar")

```

```{r echo=FALSE}

prices_int <- reactive({input$update_button
                  get_price(input$ticker_id, input$date_id) %>% 
                    select(-close) %>% 
                    rename(close = adjusted) %>% 
                  group_by(symbol) %>% 
                   tq_mutate(select = close,
                            mutate_fun = periodReturn,
                            period = "daily",
                            method = "log",
                            col_rename = "daily_return") %>% 
                    mutate(return_acc = exp(cumsum(daily_return))-1,
                           sq_return = daily_return^2)%>% 
                    ungroup()
                  })

ticker_1 <- reactive({
  input$ticker_id[1]
})

ticker_2 <- reactive({
  input$ticker_id[2]
})


output$underlying <- renderHighchart({
  
  clicks <- input$update_button
  
  isolate({
  
    highchart(type = "stock") %>%
      hc_add_series(prices_int() %>% select(-daily_return, -return_acc) %>% 
                      filter(str_detect(symbol, input$ticker_id[1])), 
                    type = "ohlc", 
                    hcaes(x = date, group = symbol),
                    name = input$ticker_id[1], color = hex_to_rgba("#7cb5ec", 0.7)) %>% 
    hc_add_series(prices_int() %>% select(-daily_return, -return_acc) %>% 
                    filter(str_detect(symbol, input$ticker_id[2])), 
                    type = "ohlc", 
                    hcaes(x = date, group = symbol), 
                    name = input$ticker_id[2], color = "#434348") %>% 
      hc_tooltip(valueDecimals = 2)

 })
  
})
  
highchartOutput("underlying")

```

## Retornos Logarítmicos

### Diário

```{r include=FALSE}

prices %>% 
  ggplot(aes(date, daily_return)) +
  geom_line() +
  facet_wrap(~symbol, nrow = 2, scales = "free")

prices %>% 
  ggplot(aes(date, return_acc, color = symbol)) +
  geom_line()
  


prices %>% 
      hchart(., "line", 
             hcaes(x = date, y = daily_return*100, group = symbol)) %>% 
      hc_plotOptions(column = list(stacking = "normal")) %>%
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Retorno Diário"),
               labels = list(format = "{value}%"))


prices %>% 
      hchart(., "line", 
             hcaes(x = date, y = return_acc*100, group = symbol)) %>% 
      hc_plotOptions(column = list(stacking = "normal")) %>%
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Retorno Acumulado"),
               labels = list(format = "{value}%"))


prices %>% 
      hchart(., "line", 
             hcaes(x = date, y = sq_return*100, group = symbol)) %>% 
      hc_plotOptions(column = list(stacking = "normal")) %>%
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Proxy da Volatilidade"),
               labels = list(format = "{value}%"))


```

No gráfico de retornos diários, nota-se a heteroscedasticidade (aglomeração de volatilidade)

```{r echo = FALSE}

output$daily_returns <- renderHighchart({
  
clicks <- input$update_button
    
isolate({
  
  prices_int() %>% 
    filter(symbol != "^BVSP") %>% 
      hchart(., "line", 
             hcaes(x = date, y = daily_return, group = symbol)) %>% 
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Retorno Diário"),
               labels = list(format = "{value}%"))
  
         })
 })


highchartOutput("daily_returns")

```

### Acumulado no período

```{r echo=FALSE}

output$acc_returns <- renderHighchart({
  
clicks <- input$update_button
    
isolate({

  prices_int() %>% 
      hchart(., "line", 
             hcaes(x = date, y = return_acc, group = symbol)) %>% 
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Retorno Acumulado"),
               labels = list(format = "{value}%"))
  
         })
 })


highchartOutput("acc_returns")

```

### Quadrado dos retornos

```{r echo = FALSE}

output$sq_returns <- renderHighchart({
  
clicks <- input$update_button
    
isolate({

  prices_int() %>% 
      hchart(., "line", 
             hcaes(x = date, y = sq_return*100, group = symbol)) %>% 
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Proxy da Volatilidade"),
               labels = list(format = "{value}%"))
  
         })
 })


highchartOutput("sq_returns")

```

# Testes

## Raíz unitária

O teste de raiz unitária é feito para verificar a estacionaridade da série temporal. No caso, se houver raiz unitária, a série *não* é estacionária.

[@Carol Alexander - II.5.3.4 Unit Root Tests]

```{r include = FALSE}

start_date <- min(prices$date)

ret_ts_1 <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    select(symbol, date, daily_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)

ret_ts_2 <- prices %>% 
    filter(str_detect(symbol, ticker_min)) %>% 
    select(symbol, date, daily_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)

px_ts_1 <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    select(symbol, date, close ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)
    
adf.test(ret_ts_1)


```

```{r echo=FALSE}

ret_ts_1 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[1])) %>% 
    select(symbol, date, daily_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)
})

ret_ts_2 <-reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[2])) %>% 
    select(symbol, date, daily_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)
})
```

-   `r ticker_1`

```{r echo=FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({

adf.test(ret_ts_1())

})

})

```

-   `r ticker_2`

```{r echo=FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({

adf.test(ret_ts_2())

})

})

```

Em ambos os casos, a hipótese nula é aceita, confirmando-se a estacionaridade dos retornos.

## Normalidade

Como é possível ver nos gráficos abaixo, para ambas ações, os retornos não podem ser considerados normais.

```{r include = FALSE}

prices %>% 
  ggplot(aes(sample = daily_return, color = symbol)) +
  geom_qq() +
  geom_qq_line() +
  scale_color_manual(values = hc_cols) +
  facet_wrap(~symbol, scales = "free")+
  labs(title = "Teste de Normalidade")

```

```{r echo = FALSE}

output$qq_plot <- renderPlot({
  
clicks <- input$update_button
    
isolate({

  prices_int() %>% 
   ggplot(aes(sample = daily_return, color = symbol)) +
   geom_qq() +
   geom_qq_line() +
   scale_color_manual(values = hc_cols) +
   facet_wrap(~symbol, scales = "free") +
   labs(title = "Teste de Normalidade")
  
         })
 })


plotOutput("qq_plot")

```

A não normalidade dos retornos também é confirmada pela curtose maior do que 3 e presença de assimetria. Lembrando que pra uma distribuição normal, não há assimetria (skewness = 0) e a curtose é igual a 3. Para as ações analisadas inicialmente, nota-se que VALE3 possui uma assimetria e cauda mais pesada do que ECOR3.

```{r include = FALSE}

rvec_1 <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    select(daily_return) %>% 
    as.vector()

rvec_2 <- prices %>% 
    filter(str_detect(symbol, ticker_min)) %>% 
    select(daily_return) %>% 
    as.vector() 


skw_1 <- skewness(rvec_1)

krt_1 <- kurtosis(rvec_1)

skw_2 <- skewness(rvec_2)

krt_2 <- kurtosis(rvec_2)


nn_test <- tibble(ticker = c(ticker_max, ticker_min),
       skewness = c(skw_1, skw_2),
       kurtosis = c(krt_1, krt_2))

nn_test %>% kable(digits = 2)

```

```{r echo = FALSE}

rvec_1 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[1])) %>% 
    select(daily_return) %>% 
    as.vector()
})

rvec_2 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[2])) %>% 
    select(daily_return) %>% 
    as.vector() 
})

```

```{r echo = FALSE}

renderTable({
  
clicks <- input$update_button

isolate({

skw_1 <- skewness(rvec_1())

krt_1 <- kurtosis(rvec_1())

skw_2 <- skewness(rvec_2())

krt_2 <- kurtosis(rvec_2())


nn_test <- tibble(ticker = c(input$ticker_id[1], input$ticker_id[2]),
       skewness = c(skw_1, skw_2),
       kurtosis = c(krt_1, krt_2))

nn_test

})

})

```

## Autocorrelação do quadrado dos retornos

Para verificar se os retornos são autocorrelacionados, é feito um teste Ljung-Box nas séries de quadrados dos retornos das duas ações.

Para definir o lag, será utilizado o logarítmo do número de linhas dos retornos conforme metodologia de [@ref]

```{r include = FALSE}

sqr_1 <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    select(sq_return) %>% 
    as.vector()

n1 <- round(log(nrow(sqr_1)))

Box.test(sqr_1, lag=7, type="Ljung-Box")

sqr_2 <- prices %>% 
    filter(str_detect(symbol, ticker_min)) %>% 
    select(sq_return) %>% 
    as.vector() 

n2 <- round(log(nrow(sqr_2)))

Box.test(sqr_2, lag=n2, type="Ljung-Box")

```

```{r echo = FALSE}

sqr_1 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[1])) %>% 
    select(sq_return) %>% 
    as.vector()
})

sqr_2 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[2])) %>% 
    select(sq_return) %>% 
    as.vector() 
})

```

-   `r ticker_1`

```{r echo=FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({

n <- round(log(nrow(sqr_1())))

Box.test(sqr_1(), lag=n, type="Ljung-Box")

})

})

```

-   `r ticker_2`

```{r echo=FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({
  
n <- round(log(nrow(sqr_2())))

Box.test(sqr_2(), lag=n, type="Ljung-Box")

})

})

```

## Efeitos ARCH

Para verificar a presença de efeitos ARCH, é feito o teste de Lagrange nas séries de quadrado dos retornos.

```{r eval=FALSE, warning=FALSE, include=FALSE}

arch_test <- prices %>%
    group_by(symbol) %>%
    tk_acf_diagnostics(date, daily_return, .lag = 703) %>%  #número máximo de lags
    mutate(acf_out = as_factor(if_else(ACF > .white_noise_upper, 1, 0)),
           pacf_out = as_factor(if_else(PACF > .white_noise_upper, 1, 0)),
           upper_limit = .white_noise_upper,
           lower_limit = .white_noise_lower)

lag_test <- arch_test %>% 
  filter(str_detect(symbol, ticker_max)) %>% 
  pull(lag)


library(fDMA)
archtest(ts = as.vector(sqr_1), lag=lag_test)

prices %>%
    group_by(symbol) %>%
    plot_acf_diagnostics(date, daily_return,
                         .lags = "50 days",
                         .show_white_noise_bars = TRUE,
                         #.x_intercept = 7,
                         .interactive = TRUE)

arch_test %>% 
  filter(lag <=60) %>% 
  ggplot(aes(lag, ACF, color = acf_out, group = symbol)) +
  geom_line(aes(lag, y = upper_limit), linetype = 2, color = "black", alpha = 0.5) +
  geom_line(aes(lag, y = lower_limit), linetype = 2, color = "black", alpha = 0.5) +
  geom_point(size = 1) +
  geom_segment(aes(x=lag, xend=lag, y=0, yend=ACF)) +
  scale_color_manual(values = c("#7cb5ec","#f7a35c")) +
  facet_wrap(~symbol, nrow = 2) +
  labs(color = "Out of interval")

arch_test %>% 
  filter(lag <=60) %>% 
  filter(str_detect(symbol, ticker_min)) %>% 
  hchart(., "lollipop", 
          hcaes(x = lag, y = ACF, group = acf_out)) %>% 
      hc_colors(c("#7cb5ec","#f7a35c")) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Lag")) %>% 
      hc_yAxis(title = list(text = "ACF"))

```

```{r include = FALSE}

renderPlot({
  
clicks <- input$update_button

isolate({
  
  prices_int() %>%
    group_by(symbol) %>%
    plot_acf_diagnostics(date, sq_return,
                         .lags = "50 days",
                         .show_white_noise_bars = TRUE,
                         #.x_intercept = 7,
                         .interactive = F)
  
})

})

```

```{r echo = FALSE}

acf_test <- reactive({
  input$update_button
  prices_int() %>%
    group_by(symbol) %>%
    tk_acf_diagnostics(date, sq_return, .lag = 703) %>%  #número máximo de lags
    mutate(acf_out = as_factor(if_else(ACF > .white_noise_upper, 1, 0)),
           pacf_out = as_factor(if_else(PACF > .white_noise_upper, 1, 0)),
           upper_limit = .white_noise_upper,
           lower_limit = .white_noise_lower)
})

arch_test <- reactive({
  input$update_button
  acf_test() %>% 
  filter(acf_out == 1, lag > 2) %>% 
    select(symbol, lag) %>% 
    top_n(-1, lag)
})


```

```{r echo = FALSE}

renderPlot({
clicks <- input$update_button

isolate({
  
acf_test() %>% 
  filter(lag <= 60) %>% 
  ggplot(aes(lag, ACF, color = acf_out, group = symbol)) +
  geom_line(aes(lag, y = upper_limit), linetype = 2, color = "black", alpha = 0.7) +
  geom_line(aes(lag, y = lower_limit), linetype = 2, color = "black", alpha = 0.7) +
  scale_color_manual(hc_cols) +
  geom_point(size = 1) +
  geom_segment(aes(x=lag, xend=lag, y=0, yend=ACF)) +
  scale_color_manual(values = c("#7cb5ec","#f7a35c")) +
  facet_wrap(~symbol, nrow = 2) +
  labs(color = "Out of interval")

})

})


```

A partir do teste ACF, é selecionados o primeiro lag após o primeiro fora do limite superior do intervalo de 95% para teste de efeito ARCH:

-   `r ticker_1`

```{r echo = FALSE}


sqr_ts_1 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[1])) %>% 
    select(symbol, date, sq_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)
})

renderPrint({
  
clicks <- input$update_button

isolate({
  
lag_test_1 <- arch_test() %>% 
  filter(str_detect(symbol, input$ticker_id[1])) %>% 
  pull(lag)

archtest(ts = sqr_ts_1(), lag=lag_test_1)


})

})


```

-   `r ticker_2`

```{r echo = FALSE}

sqr_ts_2 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[2])) %>% 
    select(symbol, date, sq_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)
})

renderPrint({
  
clicks <- input$update_button

isolate({

lag_test_2 <- arch_test() %>% 
  filter(str_detect(symbol, input$ticker_id[2])) %>% 
  pull(lag)
  

archtest(ts = as.vector(sqr_ts_2()), lag=lag_test_2)

})

})

```

Em ambos os casos a hipótese nula é rejeitada, indicando, portanto, **a presença de efeitos ARCH** da ordem selecionada.

# Box-Jenkins

## Identificação

Para essa etapa, são avaliadas a ACF e PACF das séries de retornos:

```{r}

renderPlot({
  
clicks <- input$update_button

isolate({
  
  prices_int() %>%
    group_by(symbol) %>%
    plot_acf_diagnostics(date, daily_return,
                         .lags = "50 days",
                         .show_white_noise_bars = TRUE,
                         #.x_intercept = 7,
                         .interactive = F)
  
})

})


```

## Estimação

Os lags identificados são então confirmados pela estimação `auto.arima`:

```{r eval=FALSE, include=FALSE}

arma_model_1 <- auto.arima(as.vector(ret_ts_1),
                        stationary = TRUE,
                        trace = T, ic = 'aicc')

arma_model_1$residuals %>% 
  ggtsdisplay(plot.type = 'hist' , lag.max = 14, main = ticker_max)

arma_model_1$arma[1]

ar_c_1 <-arma_model_1$arma[1]
ma_c_1 <- arma_model_1$arma[2]

arma_model_2 <- auto.arima(as.vector(ret_ts_2),
                        stationary = TRUE,
                        trace = T, ic = 'aicc')

arma_model_2$arma

```

-   `r ticker_1`

```{r echo=FALSE}

arma_1 <-  reactive({
  input$update_button
  auto.arima(as.vector(ret_ts_1()),
                        stationary = TRUE,
                        trace = T, ic = 'aicc')
  
})

arma_1_res <- reactive({
  input$update_button
  
  arma_1()$residuals
  
})

ar_coef_1 <- reactive({arma_1()$arma[1]})
ma_coef_1 <- reactive({arma_1()$arma[2]})
  
renderPrint({
  
clicks <- input$update_button

isolate({

arma_1()
  
})

})

```

-   `r ticker_2`

```{r echo=FALSE}

arma_2 <-  reactive({
  input$update_button
  auto.arima(as.vector(ret_ts_2()),
                        stationary = TRUE,
                        trace = T, ic = 'aicc')
})


arma_2_res <- reactive({
  input$update_button
  
  arma_2()$residuals
  
})

ar_coef_2 <- reactive({arma_2()$arma[1]})
ma_coef_2 <- reactive({arma_2()$arma[2]})

renderPrint({
  
clicks <- input$update_button

isolate({

arma_2()

})

})


```

## Diagnóstico

Por fim, é feito o diagnóstico dos resíduos:

```{r echo=FALSE}

renderPlot({
  
 clicks <- input$update_button

isolate({

 arma_1_res() %>% 
    ggtsdisplay(plot.type = 'hist' , lag.max = 14, main = ticker_1())

      }) 
})

renderPrint({
  
clicks <- input$update_button

isolate({

Box.test(arma_1_res(), lag = 14 , fitdf = 2 , type = 'Ljung-Box')

    }) 
})

```

```{r echo=FALSE}

renderPlot({
  
 clicks <- input$update_button

isolate({

 arma_2_res() %>% 
    ggtsdisplay(plot.type = 'hist' , lag.max = 14, main = ticker_2())

      }) 
})

renderPrint({
  
clicks <- input$update_button

isolate({

Box.test(arma_2_res(), lag = 14 , fitdf = 2 , type = 'Ljung-Box')

    }) 
})

```

De acordo com os testes de Ljung-Box, os resíduos são não autocorrelacionados, logo podemos assumir esse modelo como bem ajustado.

Segundo os testes Ljung-Box, para p-valor \> 0.05, pode-se dizer que os resíduos não são autocorrelacionados e, portanto, os modelos estão bem ajustados.

# Volatilidade

Como foi ajustado um modelo ARMA acima e verificou-se a não normalidade dos retornos, será ajustado um modelo ARMA das ordens estimadas pelo `auto.arima` e um GARCH(1,1) para previsão a volatilidade.

o modelo GARCH é dado por:

O parâmetro de erro $\alpha$ mede a reação da volatilidade condicional a choques de mercado. Quando possui valor acima de 0.1, pode ser considerado alto e permite a interpretação de uma volatilidade muito sensível a eventos ocorridos no mercado.

O parâmetro $\beta$, por outro lado, mede a persistência da volatilidade independente do que ocorre no mercado. Quando é alto (acima de 0.9), significa que a volatilidade demora para diminuir após uma crise no mercado.  

A soma desses parâmetros ($\alpha + \beta$) determina a taxa de convergência da volatilidade condicional no longo prazo. Quando essa soma é maior do 0.99, a estrutura a termo da volatilidade projetada é relativamente plana.

Por fim, o parâmetro $\omega$, alinhado à soma $\alpha + \beta$, determina o nível da média da volatilidade no longo prazo, ou seja, quando o valor de $\frac{\omega }{1 - \alpha + \beta}$ é alto, a volatilidade a longo prazo no mercado é consideravelmente alta, pois essa magnitude está relacionada à magnitude do quadrado dos retornos. (II - Alexander, C)


-   `r ticker_1`

```{r eval=FALSE, include=FALSE}

#ar_c_1
#ma_c_1
 

garch_spec <- ugarchspec(mean.model = list(armaOrder = c(ar_c_1, ma_c_1),
                                            include.mean=F), 
                          variance.model = list(garchOrder=c(1,1)), 
                          distribution.model = "std")

garch_fit_1 <- ugarchfit(spec = garch_spec, data = rets)

as.vector(ret_ts_1[1:704])

garch_fit_1@fit$matcoef

ugarchforecast(garch_fit_1, n.ahead=1, data=rets)

#?ugarchfit

rets <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    pull(daily_return)
  

```


```{r}

garch_spec_1 <- reactive({
  
   clicks <- input$update_button
  
isolate({
  
  ugarchspec(mean.model = list(armaOrder = c(ar_coef_1(), ma_coef_1()),
                                            include.mean = F), 
                          variance.model = list(garchOrder=c(1,1)), 
                          distribution.model = "std")
  })
})


garch_fit_1 <- reactive({
  
  clicks <- input$update_button
  
isolate({
 
 rvec <- prices_int() %>% 
   filter(str_detect(symbol, input$ticker_id[1])) %>% 
   pull(daily_return) 
 
 ugarchfit(spec = garch_spec_1(), data = rvec,  solver = "hybrid")
 
 })
})


renderPrint({
  
  garch_1 <- garch_fit_1()
  
  garch_1@fit$matcoef
  
})

```

-   `r ticker_2`

```{r}

garch_spec_2 <- reactive({
  
   clicks <- input$update_button
  
isolate({
  
  ugarchspec(mean.model = list(armaOrder = c(ar_coef_2(), ma_coef_2()),
                                            include.mean = F), 
                          variance.model = list(garchOrder=c(1,1)), 
                          distribution.model = "std")
  })
})


garch_fit_2 <- reactive({
  
  clicks <- input$update_button
  
isolate({
 
 rvec <- prices_int() %>% 
   filter(str_detect(symbol, input$ticker_id[1])) %>% 
   pull(daily_return) 
 
 ugarchfit(spec = garch_spec_2(), data = rvec,  solver = "hybrid")
 
 })
})


renderPrint({
  
  garch_2 <- garch_fit_2()
  
  garch_2@fit$matcoef
  
})

```

# VaR

```{r eval=FALSE, include=FALSE}

frcst <-  ugarchforecast(garch_fit_1, 
                         n.ahead = 1,
                         data = ret_ts_1[1:704])

v <- garch_fit_1@fit$matcoef["shape",][1]
print(v)

r <- frcst@forecast$seriesFor[1]
print(r)

sigma <- frcst@forecast$sigmaFor[1] #sqrt(h)
print(sigma)

t_dist <- qt(0.05, v) #conf  0.05

value_at_risk <- r + tc*sigma/sqrt((v/(v-2)))

var_tb <- tibble(t_c = tc,
              var = value_at_risk,
              total_loss = (position * var))

```

```{r}

get_var <- function(model_fit,returns, n_ahead, conf = 0.05, position){
  
frcst <-  ugarchforecast(model_fit, 
                         n.ahead = n_ahead,
                         data = returns) 

v <- model_fit@fit$matcoef["shape",][1]

r <- frcst@forecast$seriesFor[1]

sigma <- frcst@forecast$sigmaFor[1] #sqrt(h)

tc <- qt(conf, v) #conf  0.05

value_at_risk <- r + tc*sigma/sqrt((v/(v-2)))

var_tb <- tibble(t_c = tc,
              var = value_at_risk,
              total_loss = (position * var))

return(var_tb)

}


```

```{r eval=FALSE, include=FALSE}

get_var(garch_fit_1, ret_ts_1[1:704], 1, 0.05, 1000000) %>% 
  kable(align = "c")
```

## Ação

Cálculo do VaR para o dia seguinte de cada ação, considerando uma posição comprada de R\$ 1MM;

```{r}




```

```{r}


```

## Carteira

Cálculo aproximado do VaR da carteira usando correlação histórica.

```{r}



```

# Referências

- [IBOV]((http://www.b3.com.br/pt_br/market-data-e-indices/indices/indices-amplos/indice-ibovespa-ibovespa-composicao-da-carteira.htm))
- Uribe, Paloma. Material da aula Financial Analytics
- II - Alexander, Carol. Market Risk Analysis - Practical Financial Econometrics
- IV - Alexander, Carol. Market Risk Analysis - Practical Financial Econometrics
