---
title: "Volatilidade e VaR"
author: "Viviane Sanchez"
Institution: "Insper - Programa Avançado em Data Science"
date: "10/31/2020"
runtime: shiny
output: html_document
---

# Introdução

"A apresentação deve ser sucinta, contendo principalmente as conclusões de cada passo. O script deverá ser entregue junto com a apresentação e deve ser de fácil leitura. A avaliação deve levar em conta principalmente a lógica e clareza da argumentação do modelo escolhido e os cálculos realizados."

## Pacotes

```{r setup, include=FALSE}

#knitr::opts_chunk$set(message = FALSE, warning = FALSE, 
#                      fig.retina = 2 ,fig.height=5, fig.width=10)


library(tidyverse)
library(tidyquant)
library(tidymodels)
library(tidytext)
library(readxl)
library(skimr)

library(sweep)
library(timetk)


library(RcppRoll)
library(bizdays)
library(derivmkts)

library(rugarch)
library(forecast)
library(tseries)
library(fDMA)

library(ggrepel)
library(highcharter)
library(shiny)
library(knitr)


today <- Sys.Date()

bizdays.options$set(default.calendar='Brazil/ANBIMA')

theme_set(theme_minimal())
theme_update(text = element_text(family = "Open Sans", size = 12),
             plot.title = element_text(face = "bold", size = 23,
                                       color = "#1d3752"),
             legend.position = "bottom")

hc_cols <- c("#7cb5ec", "#434348", "#90ed7d", "#f7a35c", 
             "#8085e9", "#f15c80", "#e4d354", "#2b908f", 
             "#f45b5b", "#91e8e1")



#print(getwd())

```

## Objetivo

escolher duas ações do índice IBOVESPA ou SP500

# Dados

Para consulta das ações listadas no IBOV, foi extraída a [lista de ações] do site B3 do dia 30/10/20.

## Pré-processamento

```{r echo=TRUE}

ibov_raw <- list.files(path = 'data', 
                      pattern = "Ibovespa.xlsx",
                      full.names = TRUE) %>% 
    map_df(~read_excel(.), guess_max = 2000)


ibov <- ibov_raw %>% 
  janitor::clean_names() %>% 
  filter(str_detect(codigo, "\\d"))

ticker_max <- ibov %>% 
  filter(part_percent == max(part_percent)) %>% 
  pull(codigo)

ticker_min <- ibov %>% 
  filter(part_percent == min(part_percent)) %>% 
  pull(codigo)

ibov_list <- ibov %>% 
  select(codigo) %>% 
  mutate(ticker = paste(codigo,'.SA', sep = '')) %>% 
  pull(ticker)

```

O relatório será escrito baseando-se nas ações `r ticker_max` e `r ticker_min`, que são as duas ações com maior e menor participação no índice, respectivamente. No entanto, este relatório permite a simulação da análise com qualquer ação.

Para consulta das séries de preços, será utilizado o pacote `tidyquant` e os dados disponíveis através do [Yahoo! Finance](http://finance.yahoo.com). Para coleta e limpeza dos dados será utilizada a função a seguir:

```{r echo=TRUE}
get_price <- function(ticker,i_date){
    
b3_ts <- tq_get(ticker, get = "stock.prices", from = i_date) %>% 
         na.omit()

return(b3_ts)

}

```

# Análise gráfica

-   Análise gráfica dos preços e (log) retornos;

## Preços

```{r include=FALSE}

 tickers <- c(paste(ticker_max,'.SA', sep = ''), paste(ticker_min,'.SA', sep = ''))
 
 prices <- get_price(tickers, "2018-01-01") %>% 
                   select(-close) %>% 
                   rename(close = adjusted) %>% 
            group_by(symbol) %>% 
                   tq_mutate(select = close,
                            mutate_fun = periodReturn,
                            period = "daily",
                            method = "log",
                            col_rename = "daily_return") %>% 
            mutate(return_acc = exp(cumsum(daily_return))-1,
                    sq_return = daily_return^2) %>% 
            ungroup()
 
 highchart(type = "stock") %>%
  hc_add_series(prices %>% select(-daily_return, -return_acc) %>% 
                     filter(str_detect(symbol, ticker_max)), 
                     type = "ohlc", hcaes(x = date),
                     name = ticker_max, color = hex_to_rgba("#7cb5ec", 1)) %>% 
   hc_add_series(prices %>% select(-daily_return, -return_acc) %>%
                   filter(str_detect(symbol, ticker_min)), type = "ohlc", 
                   hcaes(x = date), name = ticker_min, color = "#434348") %>% 
   hc_tooltip(valueDecimals = 2)
 
```

```{r echo=FALSE}

selectInput("ticker_id", label = "Ação", choices = ibov_list,
            multiple = T,
            selected = c("VALE3.SA","ECOR3.SA")) #"^BVSP"

dateRangeInput("date_id", label = "Selecione o período", 
               start = "2018-01-18")

actionButton("update_button", "Atualizar")

```

```{r echo=FALSE}

prices_int <- reactive({input$update_button
                  get_price(input$ticker_id, input$date_id) %>% 
                    select(-close) %>% 
                    rename(close = adjusted) %>% 
                  group_by(symbol) %>% 
                   tq_mutate(select = close,
                            mutate_fun = periodReturn,
                            period = "daily",
                            method = "log",
                            col_rename = "daily_return") %>% 
                    mutate(return_acc = exp(cumsum(daily_return))-1,
                           sq_return = daily_return^2)%>% 
                    ungroup()
                  })


output$underlying <- renderHighchart({
  
  clicks <- input$update_button
  
  isolate({
  
    highchart(type = "stock") %>%
      hc_add_series(prices_int() %>% select(-daily_return, -return_acc) %>% 
                      filter(str_detect(symbol, input$ticker_id[1])), 
                    type = "ohlc", 
                    hcaes(x = date, group = symbol),
                    name = input$ticker_id[1], color = hex_to_rgba("#7cb5ec", 0.7)) %>% 
    hc_add_series(prices_int() %>% select(-daily_return, -return_acc) %>% 
                    filter(str_detect(symbol, input$ticker_id[2])), 
                    type = "ohlc", 
                    hcaes(x = date, group = symbol), 
                    name = input$ticker_id[2], color = "#434348") %>% 
      hc_tooltip(valueDecimals = 2)

 })
  
})
  
highchartOutput("underlying")

```

## Retornos Logarítmicos

### Diário

```{r include=FALSE}

prices %>% 
  ggplot(aes(date, daily_return)) +
  geom_line() +
  facet_wrap(~symbol, nrow = 2, scales = "free")

prices %>% 
  ggplot(aes(date, return_acc, color = symbol)) +
  geom_line()
  


prices %>% 
      hchart(., "line", 
             hcaes(x = date, y = daily_return*100, group = symbol)) %>% 
      hc_plotOptions(column = list(stacking = "normal")) %>%
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Retorno Diário"),
               labels = list(format = "{value}%"))


prices %>% 
      hchart(., "line", 
             hcaes(x = date, y = return_acc*100, group = symbol)) %>% 
      hc_plotOptions(column = list(stacking = "normal")) %>%
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Retorno Acumulado"),
               labels = list(format = "{value}%"))


prices %>% 
      hchart(., "line", 
             hcaes(x = date, y = sq_return*100, group = symbol)) %>% 
      hc_plotOptions(column = list(stacking = "normal")) %>%
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Proxy da Volatilidade"),
               labels = list(format = "{value}%"))


```

No gráfico de retornos diários, nota-se a heteroscedasticidade (aglomeração de volatilidade)

```{r echo = FALSE}

output$daily_returns <- renderHighchart({
  
clicks <- input$update_button
    
isolate({
  
  prices_int() %>% 
    filter(symbol != "^BVSP") %>% 
      hchart(., "line", 
             hcaes(x = date, y = daily_return, group = symbol)) %>% 
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Retorno Diário"),
               labels = list(format = "{value}%"))
  
         })
 })


highchartOutput("daily_returns")

```

### Acumulado no período

```{r echo=FALSE}

output$acc_returns <- renderHighchart({
  
clicks <- input$update_button
    
isolate({

  prices_int() %>% 
      hchart(., "line", 
             hcaes(x = date, y = return_acc, group = symbol)) %>% 
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Retorno Acumulado"),
               labels = list(format = "{value}%"))
  
         })
 })


highchartOutput("acc_returns")

```

### Quadrado dos retornos

```{r echo = FALSE}

output$sq_returns <- renderHighchart({
  
clicks <- input$update_button
    
isolate({

  prices_int() %>% 
      hchart(., "line", 
             hcaes(x = date, y = sq_return*100, group = symbol)) %>% 
      #hc_colors(cols) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Data")) %>% 
      hc_yAxis(title = list(text = "Proxy da Volatilidade"),
               labels = list(format = "{value}%"))
  
         })
 })


highchartOutput("sq_returns")

```


```{r}



```


## Testes

### Raíz unitária

"Série com raiz unitária não é estacionária"

[@Carol Alexander - II.5.3.4 Unit Root Tests]

```{r include = FALSE}

start_date <- min(prices$date)

ret_ts_1 <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    select(symbol, date, daily_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)

px_ts_1 <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    select(symbol, date, close ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)
    
adf.test(ret_ts_1)
    
adf.test(px_ts_1)

```

```{r echo=FALSE}

ret_ts_1 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[1])) %>% 
    select(symbol, date, daily_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)
})

ret_ts_2 <-reactive({
  input$update_button
     prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[2])) %>% 
    select(symbol, date, daily_return ) %>% 
    tk_ts(., start = year(start_date), silent = TRUE)
})
```

```{r echo=FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({

adf.test(ret_ts_1())

})

})

```

```{r echo=FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({

adf.test(ret_ts_2())

})

})

```

Em ambos os casos, a hipótese nula é aceita, confirmando-se a estacionaridade dos retornos.

### Normalidade

Como é possível ver nos gráficos abaixo, para ambas ações, os retornos não podem ser considerados normais.

```{r include = FALSE}

prices %>% 
  ggplot(aes(sample = daily_return, color = symbol)) +
  geom_qq() +
  geom_qq_line() +
  scale_color_manual(values = hc_cols) +
  facet_wrap(~symbol, scales = "free")+
  labs(title = "Teste de Normalidade")

```

```{r echo = FALSE}

output$qq_plot <- renderPlot({
  
clicks <- input$update_button
    
isolate({

  prices_int() %>% 
   ggplot(aes(sample = daily_return, color = symbol)) +
   geom_qq() +
   geom_qq_line() +
   scale_color_manual(values = hc_cols) +
   facet_wrap(~symbol, scales = "free") +
   labs(title = "Teste de Normalidade")
  
         })
 })


plotOutput("qq_plot")

```

A não normalidade dos retornos também é confirmada pela curtose maior do que 3 e presença de assimetria. Lembrando que pra uma distribuição normal, não há assimetria (skewness = 0) e a curtose é igual a 3. Para as ações analisadas inicialmente, nota-se que VALE3 possui uma assimetria e cauda mais pesada do que ECOR3.

```{r include = FALSE}

rvec_1 <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    select(daily_return) %>% 
    as.vector()

rvec_2 <- prices %>% 
    filter(str_detect(symbol, ticker_min)) %>% 
    select(daily_return) %>% 
    as.vector() 


skw_1 <- skewness(rvec_1)

krt_1 <- kurtosis(rvec_1)

skw_2 <- skewness(rvec_2)

krt_2 <- kurtosis(rvec_2)


nn_test <- tibble(ticker = c(ticker_max, ticker_min),
       skewness = c(skw_1, skw_2),
       kurtosis = c(krt_1, krt_2))

nn_test %>% kable(digits = 2)

```


```{r echo = FALSE}

rvec_1 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[1])) %>% 
    select(daily_return) %>% 
    as.vector()
})

rvec_2 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[2])) %>% 
    select(daily_return) %>% 
    as.vector() 
})

```

```{r echo = FALSE}

renderTable({
  
clicks <- input$update_button

isolate({

skw_1 <- skewness(rvec_1())

krt_1 <- kurtosis(rvec_1())

skw_2 <- skewness(rvec_2())

krt_2 <- kurtosis(rvec_2())


nn_test <- tibble(ticker = c(input$ticker_id[1], input$ticker_id[2]),
       skewness = c(skw_1, skw_2),
       kurtosis = c(krt_1, krt_2))

nn_test

})

})

```

## Autocorrelação do quadrado dos retornos

Para verificar se os retornos são autocorrelacionados, é feito um teste Ljung-Box nas séries de quadrados dos retornos das duas ações.

Para definir o lag, será utilizado o logarítmo do número de linhas dos retornos conforme metodologia de [@ref]

```{r include = FALSE}

sqr_1 <- prices %>% 
    filter(str_detect(symbol, ticker_max)) %>% 
    select(sq_return) %>% 
    as.vector()

n1 <- round(log(nrow(sqr_1)))

Box.test(sqr_1, lag=7, type="Ljung-Box")

sqr_2 <- prices %>% 
    filter(str_detect(symbol, ticker_min)) %>% 
    select(sq_return) %>% 
    as.vector() 

n2 <- round(log(nrow(sqr_2)))

Box.test(sqr_2, lag=n2, type="Ljung-Box")

```


```{r echo = FALSE}

sqr_1 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[1])) %>% 
    select(sq_return) %>% 
    as.vector()
})


sqr_2 <- reactive({
  input$update_button
  prices_int() %>% 
    filter(str_detect(symbol, input$ticker_id[2])) %>% 
    select(sq_return) %>% 
    as.vector() 
})

```


```{r echo=FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({

n <- round(log(nrow(sqr_1())))

Box.test(sqr_1(), lag=n, type="Ljung-Box")

})

})

```

```{r echo=FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({
  
n <- round(log(nrow(sqr_2())))

Box.test(sqr_2(), lag=n, type="Ljung-Box")

})

})

```


### Efeitos ARCH

Para verificar a presença de efeitos ARCH,

- ACF
-arch.test com lag da acf

```{r eval=FALSE, warning=FALSE, include=FALSE}

arch_test <- prices %>%
    group_by(symbol) %>%
    tk_acf_diagnostics(date, daily_return, .lag = 703) %>%  #número máximo de lags
    mutate(acf_out = as_factor(if_else(ACF > .white_noise_upper, 1, 0)),
           pacf_out = as_factor(if_else(PACF > .white_noise_upper, 1, 0)),
           upper_limit = .white_noise_upper,
           lower_limit = .white_noise_lower)

lag_test <- arch_test %>% 
  filter(str_detect(symbol, ticker_max)) %>% 
  pull(lag)


library(fDMA)
archtest(ts = as.vector(ret_ts_1), lag=lag_test)

prices %>%
    group_by(symbol) %>%
    plot_acf_diagnostics(date, daily_return,
                         .lags = "50 days",
                         .show_white_noise_bars = TRUE,
                         #.x_intercept = 7,
                         .interactive = TRUE)

arch_test %>% 
  filter(lag <=60) %>% 
  ggplot(aes(lag, ACF, color = acf_out, group = symbol)) +
  geom_line(aes(lag, y = upper_limit), linetype = 2, color = "black", alpha = 0.5) +
  geom_line(aes(lag, y = lower_limit), linetype = 2, color = "black", alpha = 0.5) +
  geom_point(size = 1) +
  geom_segment(aes(x=lag, xend=lag, y=0, yend=ACF)) +
  scale_color_manual(values = c("#7cb5ec","#f7a35c")) +
  facet_wrap(~symbol, nrow = 2) +
  labs(color = "Out of interval")

arch_test %>% 
  filter(lag <=60) %>% 
  filter(str_detect(symbol, ticker_min)) %>% 
  hchart(., "lollipop", 
          hcaes(x = lag, y = ACF, group = acf_out)) %>% 
      hc_colors(c("#7cb5ec","#f7a35c")) %>%
      hc_tooltip(valueDecimals = 2) %>% 
      hc_xAxis(title = list(text = "Lag")) %>% 
      hc_yAxis(title = list(text = "ACF"))

```


```{r echo = FALSE}

renderPlot({
  
clicks <- input$update_button

isolate({
  
  prices_int() %>%
    group_by(symbol) %>%
    plot_acf_diagnostics(date, daily_return,
                         .lags = "50 days",
                         .show_white_noise_bars = TRUE,
                         #.x_intercept = 7,
                         .interactive = F)
  
  
})

})

```


```{r echo = FALSE}

acf_test <- reactive({
  input$update_button
  prices_int() %>%
    group_by(symbol) %>%
    tk_acf_diagnostics(date, daily_return, .lag = 703) %>%  #número máximo de lags
    mutate(acf_out = as_factor(if_else(ACF > .white_noise_upper, 1, 0)),
           pacf_out = as_factor(if_else(PACF > .white_noise_upper, 1, 0)),
           upper_limit = .white_noise_upper,
           lower_limit = .white_noise_lower)
})

arch_test <- reactive({
  input$update_button
  acf_test() %>% 
  filter(acf_out == 1, lag > 2) %>% 
    select(symbol, lag) %>% 
    top_n(-1, lag)
})


```


```{r echo = FALSE}

renderPlot({
clicks <- input$update_button

isolate({
  
acf_test() %>% 
  filter(lag <= 60) %>% 
  ggplot(aes(lag, ACF, color = acf_out, group = symbol)) +
  geom_line(aes(lag, y = upper_limit), linetype = 2, color = "black", alpha = 0.7) +
  geom_line(aes(lag, y = lower_limit), linetype = 2, color = "black", alpha = 0.7) +
  scale_color_manual(hc_cols) +
  geom_point(size = 1) +
  geom_segment(aes(x=lag, xend=lag, y=0, yend=ACF)) +
  scale_color_manual(values = c("#7cb5ec","#f7a35c")) +
  facet_wrap(~symbol, nrow = 2) +
  labs(color = "Out of interval")

#acf_test() %>% 
#  filter(lag <=60) %>% 
#  filter(str_detect(symbol, input$ticker_id[1])) %>% 
#  hchart(., "lollipop", 
#          hcaes(x = lag, y = ACF, group = acf_out)) %>% 
#      hc_colors(c("#7cb5ec","#f7a35c")) %>%
#      hc_tooltip(valueDecimals = 2) %>% 
#      hc_xAxis(title = list(text = "Lag")) %>% 
#      hc_yAxis(title = list(text = "ACF"))
    

  
#"#434348"

})

})

?renderHighchart2

```

A partir do teste ACF, é selecionados o primeiro lag após o primeiro fora do limite superior do intervalo de 95% para teste de efeito ARCH:

```{r}

renderPrint({
  
clicks <- input$update_button

isolate({
  
lag_test_1 <- arch_test() %>% 
  filter(str_detect(symbol, input$ticker_id[1])) %>% 
  pull(lag)

archtest(ts = as.vector(ret_ts_1()), lag=lag_test_1)


})

})


```

statistic = 230.28, lag = 7, p-value < 2.2e-16
alternative hypothesis: ARCH effects of order 7 are present

```{r echo = FALSE}

renderPrint({
  
clicks <- input$update_button

isolate({

lag_test_2 <- arch_test() %>% 
  filter(str_detect(symbol, input$ticker_id[2])) %>% 
  pull(lag)
  

archtest(ts = as.vector(ret_ts_2()), lag=lag_test_2)

})

})



```

Em ambos os casos a hipótese nula é rejeitada, indicando, portanto, **fortes indícios de efeitos ARCH** da ordem selecionada.

## Box-Jenkins

### Identificação

Para essa etapa, é possível utilizar os lags já identificados anteriormente no item de teste de efeitos ARCH.

### Estimação

Os lags identificados são então confirmados pela estimação `auto.arima`:

```{r}

```


### Diagnóstico

Por fim, é feito o diagnóstico dos resíduos:

```{r}

```


# Volatilidade

Como foi ajustado um modelo ARMA acima, e verificou-se a não normalidade dos retornos, será ajustado um modelo GARCH para previsão a volatilidade.

Escolha, estimação e interpretação do modelo de volatilidade, incluindo: escolha das ordens e modelo, análise de resíduos e coeficientes

```{r}



```

# VaR

## Ação

Cálculo do VaR para o dia seguinte de cada ação, considerando uma posição comprada de R$ 1MM;

```{r}




```

## Carteira

Cálculo aproximado do VaR da carteira usando correlação histórica.

```{r}



```

# Referências

[IBOV]((http://www.b3.com.br/pt_br/market-data-e-indices/indices/indices-amplos/indice-ibovespa-ibovespa-composicao-da-carteira.htm))
